# Old Page Text

## Home
```
Rose Ott
Game Desinger / Programmer
Weclome to my nonesense: I make games here 
```

```
Dreams of Disquiet [link to page]
Dreams of Disquiet is the first full game I have created and published. It took me and my collaborator Steve 6 months to make, and over that time I have learned a lot about designing and implementing game mechanics, creating tools, and writing stories. As well as how to handle the full production process from pre-production to post-mortem.

Learn More → [link to page]
```

```
Weighted Array Package [link to page]
A unity package I made to add an easy way to create weighted tables for randomized selection that can be easily edited in the unity inpector.

Learn More → [link to page]
```

```
Jester's Folly [link to page]
My submission for the GMTK Game Jam 2022. I worked with my co-developer Steve over the course of 48 hours to make a game that adhered to the theme “Roll The Dice”.

Learn More → [link to page]
```

```
F = MA [link to page]
F = MA is the game I made when completing my degree at ACC. I acted as our team’s lead programmer and I wrote 95% of the code in the game. There were many interesting challenges and I learned alot about coding AI behavior, working with Quaternion, and doing lots of Vector math.

Learn More → [link to page]
```

```
Dungeon World Hacks [link to page]
I often play TTRPGs with creative people who have… interesting ideas for different characters that don’t cleanly fit the rigidly enforced fantasies of Dungeon World. Thus, I have homebrewed many different playbooks for the system, which has taught me a lot about tabletop design and how to fulfill player fantasies.

Learn More → [link to page]
```

## About
```
Greetings
A bit about me:
I am a game designer and programmer with experience in building singular mechanics in a short amount of time. I love exploring and iterating on weird and interesting gameplay mechanics to see if they have merit to them. I love working with people, and I wish to gain the opportunity to push the boundaries of storytelling in games through a stitching together of narrative and mechanics.
```

## Contact
```
Contact
Looking forward to hearing from you 

Social Media
Linkedin  Twitter

Email
admin@roseott.dev
```

## Resume
```
Project Experience

Dreams of Disquiet 
Acted as one half of a two person team designing, creating and implementing all aspects of a game
Complete dialogue system
Unique combat system
Unique movement mechanics
Infrastructure for saving/loading
Infrastructure to handle changing level state
Helped maintain, update, and revise the core of the game over a 6 months process
Designed and Implemented unique objects that let the player interact with the world around them

Snakes?
Built and created core gameplay loop over the course of eight hours
Used iterative design to refine the core gameplay loop
Used limited art and sound  assets to create a complete product
Learned to build out to Web GL to run in HTML 5

F=MA (Student Project)
Acted as the projects creative lead/main programmer which gave me the opportunity to interface with all other disciplines of production (Art, Animation, Sound, etc)
Designed and Implemented unique AIs that challenged the player interesting ways
Designed and Implemented a custom collision system to handle player and movement at high speeds
Designed and Implemented overhead systems to handle Tutorial events and level spawning
Implemented art, animation, and sound assets into the game

Dungeon World Hacks
Worked to design a concept given to me by a third party
Critiqued, review, and playtested to refine the experience with the third party player interesting ways
Wrote out clear and concise documentation on how the rules of the design worked
Designed an experience while being limited to the constraints of  a pre-existing game system
```
```
Projects again:
Cats+ Residency @ the Museum of Human Achievement (July 2024):
* Developed an interactive Karaoke night, as part of a team of 3 artists
* Wrote software to manipulate artist-generated graphics on screen in response to audio input from the user 
* Successfully captured and manipulated the composite graphical output from an old karaoke machine in response to audio input from the user
* Interfaced a touch-tone phone keypad through an Arduino microprocessor to let users select video through numbers dialed into the phone

Weight Arrays (Unity Package) - 2023:
* Successfully created a package that allows users to create weighted arrays for randomized item selection
* Wrote informative documentation for effective utilization by user of the package
* Worked with Unity’s packaged system to make it easy for user to implement the package into already existing projects 

Dreams of Disquiet - 2022:
* Acted as one half of a two person team designing, creating and implementing all aspects of a game
    * Unique combat, movement, and dialogue systems
    * Infrastructure for saving/loading
    * Infrastructure to handle changing level state
* Helped maintain, update, and revise the core of the game over a 6 months process

F=MA (Student Project) - 2021:
* Acted as the creative lead/main programmer 
* Effectively Communicated with other disciplines of game production (Art, Animation, Sound, etc)
* Coordinated and helped direct a team of over 12 people.*
* Implemented assets from other disciplines(art, animation, and sound) into the project

```
```
Skills
C# scripting
C++
Unity Expertise
Documentation Writing
Unreal
Experience with Unity Fmod
Integration
Experience with Probuilder
Analytical Thinking Skills
Microsoft Office/Google Suit
Github
Plastic SCM
```
```
Work History
Theater Technician, Volunteer Mosaic Children’s Theatre – Austin, TX

August 2017 – December 2019
```
```
Created Props utilizing 3D printing, electrical wiring, mechanical gears, and lighting effects.
Managed sound and lighting effects during performances.
Supported Stage Manager and Performers by transitioning set pieces and organizing props on cue
```
```
Education
Associate of Applied Science, Game Design

Austin Community College – Austin, TX

August 2021
```


## Snakes?
```
Overview:
This game was a departure from my other big projects, which all seemed to be have the same fate. I would start with a big idea, spend a weekend building and bashing things together until I had a mechanic that worked, and then… lose interest. The project would sit on my hard drive collecting dust and would never see the light of day. When I started the Snakes? project, I told myself that I wouldn’t let it get any bigger than it had to be.  I would devote a weekend to it and nothing more. I wanted to see if I could make something worthy of an itch.io page. After 30 hours, I accomplished that goal.
```
```
Design:
The design plan was to to make something small, that could be finished over a weekend, and was still interesting.  I made a basic Snake, which only took about 3 hours to get something playable and buildable.  And then, I decided to put an interesting spin on the Snake formula.

I sketched out three different ideas.  In the first game idea, whenever the player’s snake overlapped itself, it would turn the remaining part of that snake into food and decrease the body’s total length (e.g. Slither.io). But that wasn’t very interesting.  It didn’t affect gameplay in any meaningful way, and just set the player back a bit. 

In the second game idea, whenever a snake overlapped with itself or another snake, it would split off a new snake that would be controlled by an AI. This idea was really cool, and someday I will probably return to it.  But, during testing, it quickly became too complex for the time limitation I has set. In the third (and last) game idea, when the player’s snake overlapped itself, the snake would split off into two different snakes (as shown above). One snake can only rotate left and the other only rotate right. If the snake collides with itself, another snake, or a wall, then it dies, and the snake left alive returns to being able to rotate left and right again.  I liked this last idea the most because it was a nice balance of easy to complete in the limited time window and made an interesting impact on gameplay.
```

## Dungeon Hacks
```
Introduction
Dungeon World is a game system that inherited a lot of its design philosophy from Powered by the Apocalypse (PbtA). The core gameplay loop of Dungeon World and PbtA is a system where the player is presented with a challenge, and they roll 2d6 + any applicable modifiers.  If they roll a 10 or above (abbreviated to +10), the action they take works perfectly. If they roll between a 7 and 9 (abbreviated to 7-9), the action succeeds but not fully; something goes wrong or the player has to pay a price.  If they roll below a 6 (abbreviated to -6), the action fails and the Game Master (GM) decides the consequences.
```
```
The Megalomaniac
Player Fantasy
For this playbook, my player wanted to play a suave criminal mastermind/trickster who was also a doctor and had a cybernetic in their brain that would let them create hard light copies of objects (akin to the green lantern). Suffice it to say, this one was my most tailored playbook, designed only to fit this one very specific archetype.

Design
As explained above, this playbook is split into 3 main ideas: the trickster mastermind, the doctor, and the hard light projectionist.

The doctor is the one that has the least influence in the playbook, only being expressed in moves like “War Medicine”, “Deaths Bane”, and “You might feel a slight pinch”. When making the playbook, I knew the doctor aspect of the character needed to be part of the mechanics, because a character who is a trained medical professional needs a mechanic that allows them to heal others.

The Hard light projectionist was the hardest fantasy to implement well, mechanically. The move “Hard Light Projections” took heavy inspiration from the Green Lanterns’ powers and from Loki’s magic.  When designing the mechanic, I wanted the player to be able to create anything they wanted (within reason), and those creations to be able to have an effect on gameplay. The difficulty with this design is if the move affects gameplay, I need to be specific on how those effects work mechanically.  But, this restricts the player’s creativity in creating interesting and unique solutions to in-game problems. 
A way to accommodate this mechanic, was to focus more on the hard light projectionist fantasy.  Instead of having one move that tries to encapsulate everything, make many moves that each encapsulates a singular aspect of the hard light projectionist fantasy.

The last and most in-depth fantasy I explored was the trickster/criminal mastermind. The titular megalomaniac, if you will.  This one was the most interesting to me because I personally love playing the silver-tongued liar who is flying by the seat of his pants. Think of someone like Jack Sparrow, Loki, or The Doctor.  When looking at these characters for inspiration, I realized their strengths were in collecting information about situations very quickly.  This is why there are a lot of moves such as “What Do You Want”, “Who Am I ?!?”, and “Read the Room” that let the player gather useful information, as they plan on how they are going to lie, cheat, or steal their way out of their current predicament.

Results
When this playbook was implemented, there were a few unexpected rough patches.  The most unexpected problem was with the move “B || !B” which originally gave them a +1 to their charisma role for every 30 seconds they could keep up a monologue.  Now, 30 seconds feels like a really long time, but when you are talking about monologues, a player could routinely get a +5 or +6 making it impossible to fail the roll. This means the player would always be successful in getting the person they are talking to do what they want.  Letting the player rack up a crazy bonus like this just wasn’t fun. In the end, I increased the time it takes to get a +1 to 60 seconds.  This incentivized the player monologuing, while still retaining that tension that they might not succeed.
```

```
The Sword
Player Fantasy
One day, my player came up to me and said “Hey, Roy, can I play a living sword who has seen a thousand battles over a hundred lifetimes and is now trapped in the body of a physically weak person?”  Like the good GM I am, I said “yes, but…” and thus this playbook was born.

Design
Designing these playbooks is always tricky because neither the player nor I really know what moves should be in the playbook. They give me the generalized fantasy of being a sentient sword, but due to the collaborative nature of TTRPGs, a player never really knows what kind of character they are going to play until they start playing.  Player fantasy needs to inform the mechanics of the playbook; it determines how the player can interact with the world.  It wouldn’t make sense for a silver-tongued negotiator to only have combat moves.

In order to get around this uncertainty, I decided to design this playbook to be as generalized as possible. Going even more general than the intended fantasy of “sentient sword” and turning it into “sentient weapon”.  This generalization gave me the ability to give the player more interesting choices that they might not have considered before.  For example, there are options in the playbook that let the player play not only as a sword but also as pretty much any melee weapon, shield, or even a bow.  Likewise, all the moves that modify the player’s weapon in some way (i.e. Body Modification and Master Modification) are designed to also work with whatever weapon the player has chosen. 


Results
Once this playbook was finally implemented, there were a few aspects that my player didn’t use, such as their ability to possess a host (mainly because of the questionable ethics in overriding the host’s freewill). Also when asked, the player said they would have liked to have seen more moves related to combat and/or related to past events the sword would have been a part of. For instance, when you first stumble upon a town where the sword has been before, the player rolls (+CHA) —  for +10 they love you, for 7-9 they remember you, and for -6 they hate you.
```

```
The Ghost
Player Fantasy
This playbook appeared out of necessity when my player made a deal with a demon.  In return for freeing the demon, they wanted to be turned into a Ghost.  Long story short, the demon tried to kill them, the cleric stepped in, and we ended the session with the player’s soul being tied to a gemstone. And I was left to figure out what the fallout from that situation would be.

Design
When my player told me they wanted to be a ghost, I decided to bring in the revenant — a ghostly being too angry to die, who is held to this mortal plane by their own determination and will of steel.  I portray this fantasy in moves like “Unfinished Business” and “Death for the Undying”, and “Sword of WillPower”. 

“Death for the Undying” is probably my most creative mechanical representation of this fantasy.  There is no way to kill a ghost. The only thing you can do to them is weaken their grip on the mortal plane.  Every time they would “die”, they would just lose another aspect of their self or get drawn closer to the infinite abyss, but they would never truly die. 

In keeping with the theme of self, there are a lot of moves in this playbook that rely heavily on my playstyle as a GM and some of the more esoteric parts of the campaign setting.  A great example of this would be “The Midnight Train”, and any of the moves where the astral visage is brought up, such as “The Pale Face of Death”.  The Midnight Train” move would let

me spark these huge odysseys, spanning across the ethereal realm with vivid details. Most of that imagery is from my own enjoyment of improving dream sequences for characters; the ethereal realm is nothing but a huge dream sequence in my world.  But, I think moves like “The Midnight Train” are very interesting if the GM is open to it.  They can really lean hard into the role play and create cool sequences from a single move.

Results
When this playbook was implemented, there was a design flaw I didn’t catch.  Most of the moves for the playbook are reliant on Wisdom as their primary stat, as the player levels up, they can pour everything into that stat and become pretty much unstoppable.  Going back, I would diversify and make more moves requiring different stats like Constitution or Intelligence.
```

## F=MA
```
--Introduction--
Project Background:
This game was made in the Unity engine as part of my degree in game design from ACC. This game was built over the course of two semesters (8 months), and was made with a team of people.  On this team, I acted as the lead programmer/creative lead and wrote the game’s code in C#. 

Game Summary:
F=MA is a game about using the recoil of your gun to propel yourself through a zero gravity environment. The main bulk of the game will see the player exploring the desolate space station of Enigmas Totalis 1 – a space station that was built by K.N.O.X. Security Corp and has recently been taken over by a “malfunctioning” A.I., referred to as the Enigma Protocol.

As an agent of the K.N.O.X Corporation, the player has been tasked with going into Enigmas Totalis 1 and doing reconnaissance and clean up.  But, as the player navigates through the twisting corridors of Enigmas Totalis 1, fighting the A.I. and its minions, they uncover what happened on the station and the reason for the Enigma Protocol’s “malfunction”. 
```

```
--Player--
Overview:
The script for the player handles everything from locomotion and collisions to health and UI pretty much anything the person playing the game will be doing. Most of the coding for it was relatively straight forward.

Movemment:
The player’s locomotion uses Unity’s rigid body system to impart force to the player along the player’s forward vector.  The power and direction they are pushed is controlled by the type of gun the player has equipped and in what direction they are aiming the gun. The player can choose to either aim the gun in front of them to be pushed backwards, or behind them to move forward, as shown below.

Player Firing Backwards

Player Firing Forward

Collision:
Collisions in the game are handled by a custom collision system that I wrote because the collision system in Unity is restrictive.  It works on a fixed update cycle of 60fps, with the player moving at a top speed of 30 units per second or 0.5 units per frame. This means that if any collider is smaller than 0.5 units, the player will not detect a collision. My system gets around this limitation by checking for a collision every time the game updates, which is on a much faster (although sometimes inconsistent) cycle. 

Player Collision Side

Player Collision Front

Using Unity’s “raycast” and “overlapping capsule” functions, the code checks to see if the player’s capsule (seen in yellow) has overlapped anything in the current update cycle. If it has, a raycast is drawn in the direction the player is traveling (seen in red).  If that raycast hits anything, the player registers a collision and bounces off the surface.  By using raycast, the player doesn’t collide with any objects that might be traveling in parallel.
```

```
Overview:
The Spider droid is an enemy that can climb along pretty much any surface that is less than 45 degrees. The biggest challenge to make this enemy come to life, was Pathfinding.

Pathfinding Basics:
The spider droid’s pathfinding work with two basic functions. The first shoots out a raycast to act as the spider droid’s vision. When the raycast collides with a wall, it takes the normal of that wall face and calculates the angle between the surface the spider is crawling on and the wall the raycast has hit, in order to determine whether or not the wall is climbable. The second function takes the current position of the target object and projects it onto a plane. Building on these two basic functions, I went through three different iterations of the pathfinding algorithm before landing on an algorithm that worked.


First Approach:
My first approach to pathfinding worked a lot like the Boid movement. The spider droid would generate a number of different directions based on where the target was, where the walls were, and where other spider droids might be. It would assign different weights to each of these directions then take the average direction to move in.


Pathfinding

Pathfinding Edge Case Solved

This approach worked best in flat spaces with easy-to-calculate directions, but it couldn’t handle cliffs or corners very easily, often getting stuck in loops, trying to walk out of an area, only to walk back in again.


Pathfinding Edge Case

Second Approach:
My second approach to the pathfinding problem was to take the algorithm from my first approach and turn it into a semi-recursive function. The algorithm went something like this: First generate a set of possible directions the spider droid can move, then check a direction to see if it is obstructed (e.g. has any walls in the way that we can’t climb on or will cross over any pits).  If that direction isn’t obstructed, then generate a new set of possible directions and repeat.  After 3 repeats, the function returns only the directions from the first iteration of this loop. 


Object Detection

Object Avoidance (w/ Boid Method)

This approach fixed the bugs from the first approach, but it was very computationally expensive. Each iteration through the loop would pick ten new directions, to the power of 3 iterations of the loop. This means (given the worst possible conditions) the algorithm would generate ten directions, and then ten directions for each of those directions, and then ten more directions for each of the previous directions, for a total possible 1,000,000 combinations to be tested, Every. Single. Frame.

Third Approach:
The third and final approach I took to solving the pathfinding problem was a modification of the code from my second approach.  Instead of generating a new path every single frame, I would generate the path once, and the spider droid would follow it until it reached the end of the path, whereupon it would generate a new path.

The Donut

The Ramp

This method made the computation less expensive and fixed the pathfinding bugs from first approach. The only downside is that this solution is not as dynamic as the other two approaches. The spider droid can’t make snap judgements or compensate if the movement path changes.  For the game, which is made up of mostly static environments, this isn’t a big deal.  But, if I were to have made this enemy for a different game, then we would have had to try a fourth iteration.  Maybe a system that generates a grid of valid spaces in a given level and then uses the A* Pathfinding Algorithm to find the quickest path to the player.
```

```
--Game Manager / Event System--

Overview:
The Game Manager handles pretty much everything else in the game not already handled by a script. It is the game manager’s job to relay information between scripts and handle the scripted event sequences in the game (how they fire, what happens when two events fire at the same time, etc.)

Event System Basics:
All of the different types of events in the game use the Unity Timeline system in order to provide the team’s designers a visual way to plan out different events. Event functionality goes like this:

Once started, run through the timeline until you hit a pause marker;
While the event is paused, wait for some input from the user or game world (i.e. player presses a button, enemy dies, player hover over an object, etc);
Once this input is received, resume the timeline until either you hit a pause marker, or you reach the end of the event.
When the event is stopped, send a signal to the game manager.

Spawn Event Timeline

Wave Spawn Event:
The Wave spawning event is the most involved event of the game, because it has three different components.

The first component is a wave header. It tells the event system that a new wave is about to spawn. The wave header has two properties: “Number Of Enemies This Wave” and “Next Spawn Wave Threshold” (which is the max number of enemies remaining before another wave can be triggered.)
The second component is the spawner controller. It sends a call to the event system to spawn an enemy. The spawner controller has two properties: “Enemy Type” and “Spawnpoint Index” (which is used to choose the possible spawn location.)
The Third component is the end wave marker. It sends a message to event system to end the current wave, once the player has killed the last enemy.
Using this system gives the team’s designers an easy and visual way to structure level spawning, work out the time between spawns, and quickly edit and move around the order of spawn events.

Wave Header

Spawn Controller
```


## Dreams of Disquiet
```
Overview:
Dreams of Disquiet is a game I made in cooperation with Steve Gutierrez in the Unity game engine. The game was made over the course of 6 months (8/18/2021 – 4/25/2022). The Game can be found on itch.io here.

Dreams of Disquiet as it stands now is a first person JRPG where the player explores a variety of weird, strange, and disquieting realities. On their adventures, they will meet strange inhabitants and battle terrfiying monsters, as they begin to slowly unravel the mysteries behind the Agency holding them hostage and discover the reasons they keep coming to these disquieting places.

If any of that sounds intresting, then I would highly suggest going and playing the game for yourself, as the rest of this post is a highly indepth analysis/summary of the game’s systems and will contain massive spoilers.
```

```
--Dialogue--
Overview:
Dreams of Disquiet is built around three different gameplay loops: Dialogue, Exploration, Combat. We will discuss all three of these loops, how they are implemented, and the design philosophies behind them as we go.

When the player first enters the game they are immediatly introduced to the first of the three primary gameplay loops, Dialogue.

The Dialogue system is a dialogue tree.  The player chooses a response, which takes them to the next piece of dialogue, or exits them out of the tree. Depending on the sitaution, a response will yield either cope or emotional debuff points. The functionality of which we will get into during the combat section.


First screen
We decided to open the game with dialogue as it provideds an immediate hook into the game’s story, the central motivator for the player. It also gets the player using the WASD keys — the first 4 (and most used) of 7 total keys the player will use through out the game.

Implementation:
Dialogue is written by the designer using Google Sheets.  It is then downloaded as a .tsv (tab seperated varaible) file, converted to a .txt file, and parsed into an array in Unity at runtime.  Each row in the Google sheet becomes one element of the dialogue array.  An example sheet is shown below.  

For each row of dialogue, there is a column for Content (what the other person is saying) and three columns for each of 3 response options, which are:

Response (what the player is saying),
Cope Amount (an in-game resource given to the player for picking that response), and
Function Calls (a string of characters used to call functions in the code)
For example, the string “C,1*D,2,10” makes two function calls (which are delineated by the ‘*’ character). 
The first call “C,1” calls the continue function at index 1, which makes the dialogue continue at entry 1 in the array. 
The second call “D,2,10” calls the function to increase the emotional state debuff (an in-game combat status) at index 2 by 10 units.  (emotional states will be further explained in the combat section under dialogue.)
This system for dialogue parsing works well enough and meets all the criteria needed from a dialogue system. My favorite part of the system is the ability to add arbitrary functions calls to any dialogue response, which allows the world to change in accordance with the players actions. 

However, the downside of this system is the huge bottleneck it adds to production.  Using a spreadsheet layout makes it hard to tell what dialogues leads where.  If there is a problem in the dialogue script, you have to re-export a whole new dialogue asset and place it in the engine.  A more elegant way of handling dialogue (like Yarn Spinner, or a node based system) is the first thing on the implementation docket for when/if this project is pushed further.
```

```
--Exploration--
Camera Look:
The Exploration loop of the game consists of four different aspects: Camera Look, Movement, Inspectable Objects, and Interactable Objects. The first two are focused around how the player explores the world, and the second two focus more on what the player explores.

Unlike most games the controls for Camera Look and Movement have been switched. Where the camera is controlled by the WASD keys and the movement is controlled by the mouse. We picked these controls as the inverse of the normal first person controls because we wanted the player to immediately feel slightly uneasy.  The standard convention has become second nature to most players, so by subverting those expectations we force them out of their comfort zone, and make them hyper aware of their actions because now they have to think about what they want to do instead of just doing it.


Agency Room
We introduce the player to the Camera Look separate from movement by starting them off in the Agency Room. A very simplistic room that strips the player of their ability to walk, only letting them look around and interact with a TV in the center of the room. We decided to introduce the different modes of exploration to the player in stages in order to avoid overloading the player with new mechanics, and limiting the possibility that the player forgets about key mechanics they will need in order to progress through the game.

Movement:
Once the player interacts with the TV, they are taken into the level proper, and introduced to Movement (the second half of the Exploration loop).

The player moves by visually selecting a target and then walking to that marker.  The farther they look forward, farther away the target is placed.  The visual path is an arc.  We decided to go with an arc because a standard raycast would have the player looking at the ground most of the time.

The implementation of the move arc is pretty simple.  Basically, we generate a collection of points along a parabola using the equation –ax2 + h where x is the time component, a is the width of the parabola, and h is the height.  Once those points are generated, we draw a raycast between each point until we hit something.

Movement
Movement
Arc Cast Visualization
Arc Cast Visualization
Code Implementation
Code Implementation
This approach, while functional, lacks a certain readability by the designer, due to the abstract nature of the equation.  Basically, it is hard to anticipate how big the parabolic arc will be, or how far the player will be able to travel.  A better approach could be to generate a start, end, and mid point ahead of time, and then generate a quadratic curve.  A curve-based system would provide better control over the player’s end location, and might be implemented in a future version.

Inspectable Objects:
Inspectable Objects are the primary way we built atmosphere into our game.  We took inspiration from other JRPG and older PS1 titles (specifically Resident Evil).  Like those games, we use our lack of graphical fidelity in conjunction with the Inspect system to strengthen the overall atmosphere by forcing the player to fill in the gaps with their limited information. 

The visual representation in front of the player is bland and uninteresting.  We use the atmosphere as the spice to define what kind of experience we want the player to have.  An unexpected, yet ultimately beneficial consequence of this approach, is that we can extend playtime by adding a handful of Inspectable Objects to an otherwise plain box room.  The downside of this approach is that we have to make the Inspectable Objects contents interesting enough to be worth the player’s time.

Inspect
Inspect
Inspectable Object
Inspectable Object
Inspcetable Pickup Object
Inspcetable Pickup Object
The Inspect system is fairly simple.  Basically, we shoot out a raycast looking for an object that has the Inspectable component.  If we hit one of these objects, we display an “Eye” icon on the screen, showing the player the object is Inspectable.  Once the player right clicks on the object, we print out a string taken from the object’s script, character by character at a default rate of 1 character per 0.1 seconds. 

The object’s script also contains two invisible utilities:  a wait character and the ability to call Unity events. 

The wait character (designated as ` ) causes the script to pause 0.25 seconds before printing the next character to the screen.  This wait character adds a great deal of utility to the designer in terms of trying to get across mood and tone of the dialogue.  A better implementation of this pausing functionality could be to wait a length of time proportional to the printing time (instead of a fixed length of time).  

The second hidden mechanic is the ability to call Unity events (which are public functions from scripts). This allows us to basically trigger any kind of functionality we want.  For example, we can use Inspectable objects as pick ups, just by calling Level Manager Events (described further down this page).  There are two places for an Inspectable object to call events: On Inspect and After Inspect.  These are triggered once the player first interacts with an object and right after the player interacts with an object, respectfully.

Interactable Objects:
Interactable Objects are a class of object , whose broad definition is “do something to the player when the player clicks on it”.  Interactable Objects are a lot like Inspectable Objects.  They use the same raycast system, but with a “Hand” icon, showing the player the object is Interactable.  

There are three main classes derived from the interactable object class.  The Transition Object, which teleports the player to a new spot and plays an animation.  The Cutscene Object which directs the player to a certain spot and then plays a cutscene.  And, the Dialogue Object which causes the player to enter the dialogue gameplay loop (described above).

Interact
Interact
Transition Object
Transition Object
Cutscene Object
Cutscene Object
Dialogue Object
Dialogue Object
All three of these Interactable Objects employ Unity Events to call functions.   The specific function called is determined in the instance of the object, not the class definition.  This means Interactable Objects of the same type can call vastly different functions. 

The open-ended aspect of this system allows the designer to customize these functions as needed.  Which, in turn, varies the player’s experiences with these objects.  Thus, a designer can build a wide variety of interactions with only a handful of functions.

However, the major problem with this system, is that it’s not appropriate for a large-scale project.  The system works for our two-person team, because Steve and I both know how to code, and we are so deep in this project that we know it inside and out.  If additional designers were brought into the team, then the ability to make arbitrary function quickly becomes dangerous.  The designer has too much power to break things and would be terribly lost in the system. 

To make the Interactable Object system more appropriate for a large-scale project, we would want to abstract it out and make function calls safer.
```

```
--Combat--
Overview:
When Steve and I were first designing the systems for this game (especially the combat system), we were greatly inspired by this video (credit: YOURLOCALBREADMAN).  Just the sheer weirdness of the concept alone was electrifying, and we wanted to build systems that invoked similar feelings to those in the video.

However, we really didn’t want to make a menu-driven, turn-based combat system like every other JRPG.  Partly because it has been done before, but mainly because it is just so boring and passive.  So, we built a pseudo-real-time system inspired by the old school JRPG systems, along with a large helping of Punchout. 

Combat can be broken down into two different phases.  The first phase is the Dialogue, where the player gains Cope while talking to the enemy (to put them in a certain emotional state).  And the second phase of combat is the actual fighting, where you can punch, block, stun, as well as sling power words at your opponent.

Dialogue:
The dialogue system inside the Combat gameplay loop engages the player (when they are evaluating a dialogue choice) by forcing a prognostic response.  The player has to ask themselves not “What would my character do?”, but instead “How will this enemy respond?”

We designed the system this way to keep the player involved.  The player will fight the same enemy with the same dialogue multiple times over the course of the game.  The player could get really bored (if they decide to roleplay) as it necessitates their character giving the same response each time.  To alleviate that boredom, we want to encourage the player to try out different responses and be active in the dialogue every time they fight repeat enemies.

As the player progresses through the Dialogue system, an invisible counter for one (of eight) emotional states is incremented.  

Dialogue in Combat
Dialogue in Combat
Debuff List in Game
Debuff List in Game
At the end of the dialogue, assuming the player has one or more emotional states above zero, they will be prompted to choose an emotional state (a “Debuff”) to put the enemy in.  There are 8 Debuffs, each associated with one of the emotional states listed below.  The associations are also listed in the table on the right.

These Debuffs are designed to change the entire dynamic of combat.  For example,  The Moon causes the enemy to hit harder but slower. The Hanged Man increases health equal to the damage dealt. 

Emotional States:

The Wheel – The Enemy does a series of attacks in quick succession .
Judgement – Deal damage to the enemy equal to your amount of cope.
The Hanged Man – Whenever someone deals damage they heal
Temperance – Forces the enemy into a specific attack pattern.
The Fool – Everyone heals.
The Moon – Your opponent is stronger but hits slower.
The Magician – Your power words last longer.
The Star – Longer stun windows, shorter stun durations, and every time you stun the enemy you gain cope.
These states will almost always make things easier on the player in one way or another.  Not good at blocking? Use The Hanged Man so you regain health on attacks. Good at blocking, but can’t keep up with the normal pace of combat? No worries; use The Moon to make the enemy attack slower, or use Temperance to make them attack in a specific and identifiable pattern.

Because of the way emotional states change combat, they have a certain utility to the player.  This utility will cause the player to want to search for these emotional states in the dialogue, which will (hopefully) keep them engaged with repeating trees.

Power Words:
Power Words are used in place of what are normally called “spells” or “abilities” in other JRPGs, and they are fueled with “Cope” (a resource that players collect from dialogue).  Basically, Power Words put some kind of status effect on the enemy.  For example, the two Power Words that are currently implemented in the game are: “Poison” (which deals damage over time), and “Halt” (which freezes the enemy in place for a certain amount of time).

The way Power Words are implemented is somewhat inefficient because the system is a hold-over from an earlier version.  Previously, the game had 10 possible Power Words, all with wide variation in behavior and properties.  All those words would trigger in slightly different ways, so there was no clean way of defining them from an OOP (Object-Oriented Programming) perspective.

Power Word Scriptable Object
Power Word Scriptable Object
Power Word "Halt"
Power Word "Halt"
Instead, I used a scriptable object (essentially read-only data) that holds a few miscellaneous and conditional properties, plus a string that defines a function to invoke.  Now, all the Power Word functions are hard coded, and thus aren’t changeable outside of working with the code directly. 

Additionally, when the Combat system was updated, some Power Words were eliminated.  This slimmed down the in-game selection to only 4 possible Power Words.  Additional revising of this system will need to be done in a later build.  

Combat:
Combat is a very simplistic affair. When the player throws a punch, they deal damage to the enemy.  If the enemy takes damage in a specific time window, they get stunned.  If the player blocks, they take less damage, and if they block just in time ,they take no damage. 

There aren’t any interruptions or interactions from the world that have to be designed around.   So when, for example, the enemy throws a punch, we know for a fact the player will take some form of damage — normal damage, reduced damage from blocking, or completely negated damage due to perfect blocking.

Because of this certainty, we can embed function calls into the animations that will either run functions to set states in the player/enemy, or run functions to do checks against the player’s/enemy’s state.

Attack
Attack
Attack Animation
Attack Animation
Blocking
Blocking
Start Block Animation
Start Block Animation
End Block Animation
End Block Animation
In turn, this simplistic design allows easier revision and experimentation.  We can add or rework features without taking a large amount of development time. 

For example, here is a list of everything that was not in our first conceptions of combat:

Stunning
Attacking and Blocking with the left and right mouse buttons
Left Shift to use Power Words
Slowing down time when using Power Words
Dialogue at the beginning of combat
Emotional states
Perfect Blocking
Variable damage timer speeds
 We were able to add these combat system components, more or less feature complete, in the span of about a week (give or take a few hours for last minute changes).
```

```
--Infrastructure--
Level Manager Events:
The Level Manager handles most of the behind the scenes work of the level.  And, it handles all of connections between the Game Manager (the script in charge of saving and loading) and the level.  The Level Manager utilizes Level Events.

A Level Event contains a Before Event and an After Event, which are stored as Unity Event variables.  A Level Event also contains a bool that determines which of the subevents (Before or After) is called.  The upside to this system is its flexibility, which allows designers to easily read and build-in new functionality.

The downsides to this system, however, are two-fold.  Firstly, Level Events don’t work on objects that are instantiated at runtime.  This means you can’t spawn an object and then change its properties by calling a Level Event).  And secondly, the system is vastly inefficient for objects that could have multiple states. 


Level Events
These two downsides can be overcome through clever workarounds or other helper scripts.   But, for two people working on this game (and not getting paid for their time), the Level Manager system (like the other systems in this document) works perfectly satisfactory. 

In a future version of the game, the Level Manager could be revised to store an array of Unity Events inside each Level Event, instead of just the two before and after events.  Instead of a bool, the Level Manager would use an index to track what event in the array was just executed.  This revision would allow the system to handle multiple states for an object. 

To fix the instantiated objects issue, however, would require a listener/receiver-based solution with the ability to call functions on an object that may or may not exist yet.  This solution was outside the scope of our game design.
```

```
--Conclusion--
I have learned a lot over the six months it took us to create this game. From the high level workflow concepts to the nitty gritty details of C# and the Unity engine.  I have learned how to work with another person on a day to day basis. I have now seen all aspects of production on a complete timeline from pre-production to post-mortems, and I have faced the challenges that come with all of those stages.  I have developed a better sense of guesstimating how long it takes to move a feature from design documentation, to feature complete, to polished. 

The biggest lesson I have taken away from this project is that development tools are really important!  Tools aren’t just quality of life improvements, but are also vital to a healthy workflow process.  Tools can determine whether a game takes 4 months to develop or 6 months.  Applying this lesson to my subsequent projects, I will not only sketch out what designs I need to make a good game, but also what tools I need to turn that design into reality.
```

## Misc Notes
*Weighted Array Packages links to a github*

*Jesters Folly links to the itch.io page.*